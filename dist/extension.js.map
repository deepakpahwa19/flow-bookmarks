{"version":3,"sources":["../webpack/bootstrap","../external \"vscode\"",".././src/model/Bookmark.ts",".././src/model/Flow.ts",".././src/constants/constants.ts",".././src/controller/BookmarkController.ts",".././src/controller/WorkspaceController.ts",".././src/treeView/BookmarkFlowWiseProvider.ts",".././src/controller/EditorController.ts",".././src/extension.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","Bookmark","bookmarkName","flowName","index","flowIndex","this","trim","Flow","bookmarksIndexes","push","COLORS","context","workspaceController","editorController","activeEditor","activeTextEditor","bookmarkText","filePath","lineNumber","getFilePathAndLine","addOrEditBookmark","Number","enteredBookmarkName","enteredFlowName","enteredIndex","split","map","text","storedBookmarks","getBookmarks","listOfFlows","getFlows","Array","isArray","previousFlowIndex","bookmarkIndexList","length","pop","getIndexOfExistingOrNewFLow","flowObject","flow","getbookmarksIndexes","addNewBookmarkIndex","newBookmark","getName","updateBookmarks","updateFlows","decorateActiveEditor","clearOrDeleteBookmark","showInformationMessage","filteredBookmark","keys","forEach","line","toString","clearAllFlows","clearAllBookmarks","activeEditorBookmarks","getActiveEditorBookmarks","displayBookmarkForActiveEditor","fullFilePath","document","uri","fsPath","rootPath","substring","selection","active","toLowerCase","savedBookmarks","workspaceState","update","storedFlows","flows","bookmark","workSpaceRoot","colors","_onDidChangeTreeData","onDidChangeTreeData","event","offset","fire","element","getFileName","Promise","resolve","getBookmarksForFlow","label","getListOfFlow","listOfFlow","getListOfFlowNames","color","Collapsed","asAbsolutePath","sort","a","b","flowNameA","getLabel","flowNameB","bookmarksForFlow","bookmarks","indexOfBookmark","fileName","substr","lastIndexOf","None","command","title","arguments","getIndex","collapsibleState","iconPath","contextValue","super","bookmarkDecoratorList","createTextEditorDecorationType","gutterIconPath","uriDocBookmark","file","openTextDocument","then","doc","showTextDocument","editor","parseInt","column","reviewType","InCenter","InCenterIfOutsideViewport","newSe","revealRange","linesOfEachFLow","rangeObject","range","rangeBehaviour","OpenClosed","hoverMessage","lines","setDecorations","activate","bookmarkFlowWiseProvider","bookmarkController","undefined","listOfColors","getConfiguration","registerTreeDataProvider","init","registerCommand","node","refresh","onDidChangeActiveTextEditor","addNew","showInputBox","prompt","placeHolder","enteredText","addBookmark","executeCommand","editBookmark","inputBoxOptions","clearBookmark","showWarningMessage","deleteBookmark","subscriptions","deactivate"],"mappings":"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","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = require(\"vscode\");","/** @format */\n\nexport class Bookmark {\n  bookmarkName: string;\n  flowName: string;\n  index: number;\n  flowIndex: number;\n\n  constructor(bookmarkName: string, flowName: string, index: number, flowIndex: number) {\n    this.bookmarkName = bookmarkName.trim();\n    this.index = index;\n    this.flowName = flowName;\n    this.flowIndex = flowIndex;\n  }\n\n  getBookmarkName(): string {\n    return this.bookmarkName;\n  }\n\n  getFlow(): string {\n    return this.flowName;\n  }\n\n  getIndex(): number {\n    return this.index;\n  }\n}\n","/** @format */\n\nexport class Flow {\n  private bookmarksIndexes: number[];\n  private name: string;\n  constructor(name: string, bookmarksIndexes: number[] = []) {\n    this.name = name;\n    this.bookmarksIndexes = bookmarksIndexes;\n  }\n\n  getbookmarksIndexes(): number[] {\n    return this.bookmarksIndexes;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  addNewBookmarkIndex(index: number): void {\n    this.bookmarksIndexes.push(index);\n  }\n}\n","/** @format */\n\nexport const UNCATEGORISED = 'Uncategorised';\nexport const BOOKMARKS = 'bookmarks';\nexport const FLOWS = 'flows';\nexport const COLORS = ['blue', 'red', 'pink', 'purple', 'yellow'];\n","/** @format */\nimport * as vscode from 'vscode';\nimport { Bookmark } from '../model/Bookmark';\nimport { WorkspaceController } from './WorkspaceController';\nimport { EditorController } from './EditorController';\nimport { Flow } from '../model/Flow';\nimport { UNCATEGORISED } from '../constants/constants';\n\nexport class BookmarkController {\n  constructor(\n    private context: vscode.ExtensionContext,\n    private workspaceController: WorkspaceController,\n    private editorController: EditorController\n  ) {}\n\n  addBookmark(activeEditor: any = vscode.window.activeTextEditor, bookmarkText: string) {\n    const { filePath, lineNumber } = this.getFilePathAndLine(activeEditor);\n    this.addOrEditBookmark(filePath, lineNumber, bookmarkText);\n  }\n\n  editBookmark(filePath: string, lineNumber: string, bookmarkText: string) {\n    this.addOrEditBookmark(filePath, Number(lineNumber), bookmarkText);\n  }\n\n  private addOrEditBookmark(filePath: string, lineNumber: number, bookmarkText: string = UNCATEGORISED) {\n    const [enteredBookmarkName, enteredFlowName, enteredIndex] = bookmarkText.split(',').map(text => text.trim()) || [],\n      storedBookmarks: any = this.workspaceController.getBookmarks(),\n      flowName: string = enteredFlowName || UNCATEGORISED;\n\n    let listOfFlows: any = this.workspaceController.getFlows();\n    listOfFlows = Array.isArray(listOfFlows) ? listOfFlows : [];\n\n    // Removing existing flow on the lineNumber\n    if ((storedBookmarks[filePath] || {})[lineNumber]) {\n      const previousFlowIndex = storedBookmarks[filePath][lineNumber].flowIndex,\n        bookmarkIndexList: any[] = listOfFlows[previousFlowIndex].bookmarksIndexes;\n\n      bookmarkIndexList.length === 1 ? (listOfFlows[previousFlowIndex] = null) : bookmarkIndexList.pop();\n    }\n\n    const flowIndex = this.getIndexOfExistingOrNewFLow(listOfFlows, flowName), // To get the index of existing or new flowName\n      flowObject = listOfFlows[flowIndex],\n      flow = flowIndex < listOfFlows.length && flowObject ? new Flow(flowObject.name, flowObject.bookmarksIndexes) : new Flow(flowName),\n      index = enteredIndex ? Number(enteredIndex) : flow.getbookmarksIndexes().length;\n\n    flow.addNewBookmarkIndex(index);\n\n    flowIndex < listOfFlows.length ? (listOfFlows[flowIndex] = flow) : listOfFlows.push(flow);\n\n    // Creating and Saving Bookmark\n    const newBookmark = new Bookmark(enteredBookmarkName, flow.getName(), index, flowIndex);\n    storedBookmarks[filePath] = storedBookmarks[filePath] || {};\n    storedBookmarks[filePath][lineNumber] = newBookmark;\n\n    this.workspaceController.updateBookmarks(storedBookmarks);\n    this.workspaceController.updateFlows(listOfFlows);\n\n    this.decorateActiveEditor();\n  }\n\n  clearBookmark(activeEditor: any = vscode.window.activeTextEditor) {\n    const { filePath, lineNumber } = this.getFilePathAndLine(activeEditor);\n    this.clearOrDeleteBookmark(filePath, lineNumber);\n  }\n\n  deleteBookmark(filePath: string, lineNumber: string) {\n    this.clearOrDeleteBookmark(filePath, Number(lineNumber));\n  }\n\n  private clearOrDeleteBookmark(filePath: string, lineNumber: number) {\n    const storedBookmarks = this.workspaceController.getBookmarks();\n    let flowName: string = '',\n      flowIndex: number = -1;\n\n    // Removing the Bookmark from the file\n    if (storedBookmarks[filePath] && storedBookmarks[filePath][lineNumber]) {\n      const filteredBookmark: any = {};\n      Object.keys(storedBookmarks[filePath]).forEach((line: string): void => {\n        if (line !== lineNumber.toString()) {\n          filteredBookmark[line] = filteredBookmark[line] || {};\n          filteredBookmark[line] = storedBookmarks[filePath][line];\n        } else {\n          flowName = storedBookmarks[filePath][line].flowName;\n          flowIndex = Number(storedBookmarks[filePath][line].flowIndex);\n        }\n      });\n      storedBookmarks[filePath] = filteredBookmark;\n    } else {\n      vscode.window.showInformationMessage('This line does not have any bookmark');\n      return;\n    }\n\n    // Removing the flow\n    const listOfFlows: any[] = this.workspaceController.getFlows(),\n      flow: any = new Flow(listOfFlows[flowIndex].name, listOfFlows[flowIndex].bookmarksIndexes);\n\n    // Poping one item to decrease the count of bookmarks for this flow\n    flow.bookmarksIndexes.pop();\n    listOfFlows[flowIndex] = flow.bookmarksIndexes.length > 0 ? flow : null;\n    this.workspaceController.updateFlows(listOfFlows);\n    this.workspaceController.updateBookmarks(storedBookmarks);\n    this.decorateActiveEditor();\n  }\n\n  clearAllBookmarks() {\n    this.workspaceController.clearAllFlows();\n    this.workspaceController.clearAllBookmarks();\n    this.decorateActiveEditor();\n  }\n\n  decorateActiveEditor(activeEditor: any = vscode.window.activeTextEditor) {\n    const activeEditorBookmarks = this.workspaceController.getActiveEditorBookmarks(activeEditor);\n    this.editorController.displayBookmarkForActiveEditor(activeEditor, activeEditorBookmarks);\n  }\n\n  private getFilePathAndLine(activeEditor: any = vscode.window.activeTextEditor): { filePath: string; lineNumber: number } {\n    const fullFilePath: string = activeEditor.document.uri.fsPath,\n      length = vscode.workspace.rootPath?.length || 0,\n      filePath = fullFilePath.substring(length);\n    return {\n      filePath,\n      lineNumber: activeEditor.selection.active.line,\n    };\n  }\n\n  private getIndexOfExistingOrNewFLow(listOfFlows: any[], flowName: string): number {\n    let flowIndex: number = -1;\n    for (let index = 0; index < listOfFlows.length; index++) {\n      const flow: any = listOfFlows[index];\n      if (flow && flow.name.toLowerCase() === flowName.toLowerCase()) {\n        flowIndex = index;\n        break;\n      } else if (!flow && flowIndex < 0) {\n        // to get first Null Object in array\n        flowIndex = index;\n      }\n    }\n    return flowIndex >= 0 ? flowIndex : listOfFlows.length;\n  }\n}\n","/** @format */\n\nimport * as vscode from 'vscode';\nimport { BOOKMARKS, FLOWS } from '../constants/constants';\nexport class WorkspaceController {\n  context: vscode.ExtensionContext;\n  savedBookmarks: any;\n  constructor(context: vscode.ExtensionContext) {\n    this.context = context;\n    this.savedBookmarks = {};\n  }\n\n  getBookmarks(): any {\n    return this.context.workspaceState.get(BOOKMARKS) || {};\n  }\n\n  updateBookmarks(storedBookmarks: any): void {\n    this.context.workspaceState.update(BOOKMARKS, storedBookmarks);\n  }\n\n  clearAllBookmarks(): void {\n    this.context.workspaceState.update(BOOKMARKS, {});\n  }\n\n  getFlows(): any {\n    return this.context.workspaceState.get(FLOWS) || [];\n  }\n\n  updateFlows(storedFlows: any[]): void {\n    this.context.workspaceState.update(FLOWS, storedFlows);\n  }\n\n  clearAllFlows(): void {\n    this.context.workspaceState.update(FLOWS, []);\n  }\n\n  getActiveEditorBookmarks(activeEditor: any = vscode.window.activeTextEditor): any {\n    const fullFilePath: string = activeEditor.document.uri.fsPath,\n      length = vscode.workspace.rootPath?.length || 0,\n      filePath = fullFilePath.substring(length) || '',\n      storedBookmarks = this.getBookmarks();\n    return storedBookmarks[filePath];\n  }\n\n  getListOfFlowNames(): any {\n    this.savedBookmarks = {};\n    const flows: any = {};\n    const storedBookmarks = this.getBookmarks();\n    Object.keys(storedBookmarks).forEach((filePath: string) => {\n      Object.keys(storedBookmarks[filePath]).forEach((lineNumber: string) => {\n        const bookmark = storedBookmarks[filePath][lineNumber];\n        if (!flows[bookmark.flowName]) {\n          flows[bookmark.flowName] = bookmark.flowIndex;\n        }\n        this.savedBookmarks[bookmark.flowName] = this.savedBookmarks[bookmark.flowName] || {};\n        this.savedBookmarks[bookmark.flowName][filePath] = this.savedBookmarks[bookmark.flowName][filePath] || {};\n        this.savedBookmarks[bookmark.flowName][filePath][lineNumber] = this.savedBookmarks[bookmark.flowName][filePath][lineNumber] || {};\n        this.savedBookmarks[bookmark.flowName][filePath][lineNumber].bookmarkName = bookmark.bookmarkName;\n        this.savedBookmarks[bookmark.flowName][filePath][lineNumber].index = bookmark.index;\n        this.savedBookmarks[bookmark.flowName][filePath][lineNumber].flowIndex = bookmark.flowIndex;\n      });\n    });\n\n    /*\n    this.savedBookmarks:{\n      flowName: {\n        fileName: {\n          lineNumber: {\n            bookmarkName: 'activate',\n            index: 12\n          }\n        }\n      }\n    }\n    */\n\n    return flows;\n  }\n\n  getBookmarksForFlow(flowName: string): {} {\n    return this.savedBookmarks[flowName];\n  }\n}\n","/** @format */\n\nimport * as vscode from 'vscode';\nimport { WorkspaceController } from '../controller/WorkspaceController';\n\nexport class BookmarkFlowWiseProvider implements vscode.TreeDataProvider<StoredBookmarks> {\n  constructor(\n    private workSpaceRoot: string | undefined,\n    private workspaceController: WorkspaceController,\n    private context: vscode.ExtensionContext,\n    private colors: string[]\n  ) {}\n\n  private _onDidChangeTreeData: vscode.EventEmitter<StoredBookmarks> = new vscode.EventEmitter<StoredBookmarks>();\n  readonly onDidChangeTreeData: vscode.Event<StoredBookmarks> = this._onDidChangeTreeData.event;\n\n  refresh(offset: StoredBookmarks): void {\n    this._onDidChangeTreeData.fire(offset);\n  }\n\n  getTreeItem(element: StoredBookmarks): vscode.TreeItem {\n    return element;\n  }\n\n  getChildren(element: StoredBookmarks): Thenable<StoredBookmarks[]> {\n    if (!this.workSpaceRoot) {\n      vscode.window.showInformationMessage('No workspace root was provided...');\n    }\n\n    if (element) {\n      if (element.getFileName()) {\n        return Promise.resolve([]); // to stop triggering getChildren method\n      } else {\n        return Promise.resolve(this.getBookmarksForFlow(element.label));\n      }\n    } else {\n      return Promise.resolve(this.getListOfFlow());\n    }\n  }\n\n  private getListOfFlow(): StoredBookmarks[] {\n    let listOfFlow: StoredBookmarks[] = [];\n    const flows: any = this.workspaceController.getListOfFlowNames();\n\n    listOfFlow = Object.keys(flows).map(flowName => {\n      const color = this.colors[flows[flowName] % this.colors.length];\n      return new StoredBookmarks(flowName, vscode.TreeItemCollapsibleState.Collapsed, this.context.asAbsolutePath(`images/bookmark-${color}.svg`));\n    });\n    return listOfFlow.sort((a: StoredBookmarks, b: StoredBookmarks) => {\n      const flowNameA = a.getLabel(),\n        flowNameB = b.getLabel();\n      return flowNameA < flowNameB ? -1 : flowNameA > flowNameB ? 1 : 0;\n    });\n  }\n\n  private getBookmarksForFlow(flowName: string): StoredBookmarks[] {\n    const bookmarksForFlow: any = this.workspaceController.getBookmarksForFlow(flowName);\n    const bookmarks: StoredBookmarks[] = [];\n    Object.keys(bookmarksForFlow).forEach((filePath: string) => {\n      Object.keys(bookmarksForFlow[filePath]).forEach(lineNumber => {\n        const indexOfBookmark = Number(bookmarksForFlow[filePath][lineNumber].flowIndex) % this.colors.length,\n          color = this.colors[indexOfBookmark],\n          fileName = filePath.substr(filePath.lastIndexOf('/') + 1);\n        bookmarks.push(\n          new StoredBookmarks(\n            bookmarksForFlow[filePath][lineNumber].index + '. ' + bookmarksForFlow[filePath][lineNumber].bookmarkName,\n            vscode.TreeItemCollapsibleState.None,\n            this.context.asAbsolutePath(`images/bookmark-${color}.svg`),\n            fileName,\n            lineNumber,\n            bookmarksForFlow[filePath][lineNumber].index,\n            flowName,\n            {\n              command: 'flowBookmark.jumpTo',\n              title: '',\n              arguments: [filePath, lineNumber, flowName],\n            },\n            'dependency'\n          )\n        );\n      });\n    });\n    return bookmarks.sort((a: StoredBookmarks, b: StoredBookmarks) => a.getIndex() - b.getIndex());\n  }\n}\n\nclass StoredBookmarks extends vscode.TreeItem {\n  constructor(\n    public readonly label: string,\n    public readonly collapsibleState: vscode.TreeItemCollapsibleState,\n    public iconPath?: string,\n    public fileName?: string | undefined,\n    // public filePath?: string | undefined,\n    public lineNumber?: string,\n    public index?: number,\n    public flowName?: string,\n    public readonly command?: vscode.Command,\n    public contextValue?: string\n  ) {\n    super(label, collapsibleState);\n  }\n\n  get tooltip(): string {\n    return `${this.index}.${this.label}- ${this.fileName}`;\n  }\n\n  get description(): string | undefined {\n    return this.fileName && this.lineNumber ? `${this.fileName} - ${Number(this.lineNumber) + 1}` : '';\n  }\n\n  getFileName(): string | undefined {\n    return this.fileName;\n  }\n\n  getIndex(): number {\n    return this.index || 0;\n  }\n\n  getLabel(): string {\n    return this.label;\n  }\n}\n","/** @format */\n\nimport * as vscode from 'vscode';\n\nexport class EditorController {\n  bookmarkDecoratorList: any;\n  colors: string[] = [];\n  context: vscode.ExtensionContext;\n\n  constructor(context: vscode.ExtensionContext, colors: string[]) {\n    this.context = context;\n    this.colors = colors;\n    this.bookmarkDecoratorList = this.colors.map(color => {\n      return vscode.window.createTextEditorDecorationType({\n        gutterIconPath: context.asAbsolutePath(`images/bookmark-${color}.svg`),\n      });\n    });\n  }\n\n  openTextDocument(filePath: string, lineNumber: string): void {\n    filePath = vscode.workspace.rootPath + filePath;\n    const uriDocBookmark = vscode.Uri.file(filePath);\n    vscode.workspace.openTextDocument(uriDocBookmark).then(doc => {\n      vscode.window.showTextDocument(doc).then(editor => {\n        const line: number = parseInt(lineNumber, 10);\n        const column: number = parseInt(lineNumber, 10) + 100;\n        let reviewType: vscode.TextEditorRevealType = vscode.TextEditorRevealType.InCenter;\n        if (editor.selection.active.line === line) {\n          reviewType = vscode.TextEditorRevealType.InCenterIfOutsideViewport;\n        }\n        const newSe = new vscode.Selection(line, column, line, column);\n        editor.selection = newSe;\n        editor.revealRange(newSe, reviewType);\n      });\n    });\n  }\n\n  displayBookmarkForActiveEditor(activeEditor: vscode.TextEditor, activeEditorBookmarks: any) {\n    const linesOfEachFLow: any[][] = this.colors.map(color => []); // [[],[],[]]\n    if (activeEditorBookmarks) {\n      Object.keys(activeEditorBookmarks).forEach(lineNumber => {\n        const rangeObject = {\n          range: new vscode.Range(new vscode.Position(Number(lineNumber), 0), new vscode.Position(Number(lineNumber), 10)),\n          rangeBehaviour: vscode.DecorationRangeBehavior.OpenClosed,\n          hoverMessage:\n            activeEditorBookmarks[lineNumber].bookmarkName +\n              ', ' +\n              activeEditorBookmarks[lineNumber].flowName +\n              ', ' +\n              activeEditorBookmarks[lineNumber].index || '',\n        };\n        const arr = linesOfEachFLow[Number(activeEditorBookmarks[lineNumber].flowIndex) % this.colors.length];\n        arr.push(rangeObject);\n      });\n    }\n    linesOfEachFLow.forEach((lines, index) => activeEditor.setDecorations(this.bookmarkDecoratorList[index], lines));\n  }\n}\n","/** @format */\n\n// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport { BookmarkController } from './controller/BookmarkController';\nimport { WorkspaceController } from './controller/WorkspaceController';\nimport { BookmarkFlowWiseProvider } from './treeView/BookmarkFlowWiseProvider';\nimport { EditorController } from './controller/EditorController';\nimport { COLORS } from './constants/constants';\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n  let colors: string[] = COLORS;\n  let editorController: EditorController,\n    workspaceController: WorkspaceController,\n    bookmarkController: any = undefined,\n    bookmarkFlowWiseProvider: BookmarkFlowWiseProvider;\n\n  function init() {\n    const listOfColors: any = vscode.workspace.getConfiguration('flowbookmark');\n    colors = listOfColors.get('listOfColors').length > 0 && listOfColors.get('listOfColors').length < 11 ? listOfColors.get('listOfColors') : COLORS;\n    editorController = new EditorController(context, colors);\n    workspaceController = new WorkspaceController(context);\n    bookmarkController = new BookmarkController(context, workspaceController, editorController);\n    bookmarkFlowWiseProvider = new BookmarkFlowWiseProvider(vscode.workspace.rootPath, workspaceController, context, colors);\n    vscode.window.registerTreeDataProvider('flowBookmarksView', bookmarkFlowWiseProvider);\n  }\n\n  init();\n\n  if (bookmarkController) {\n    bookmarkController.decorateActiveEditor();\n  }\n\n  vscode.commands.registerCommand('flowBookmarksView.refreshEntry', node => {\n    bookmarkFlowWiseProvider.refresh(node);\n  });\n\n  //Events\n  vscode.window.onDidChangeActiveTextEditor(editor => {\n    if (editor && editor.document === vscode.window.activeTextEditor?.document) {\n      bookmarkController.decorateActiveEditor(editor);\n    }\n  });\n\n  // Commands\n  // Add a new bookmark from command prompt\n  let addNew = vscode.commands.registerCommand('flowbookmark.addNew', () => {\n    const activeEditor: any = vscode.window.activeTextEditor;\n    if (!activeEditor) {\n      return vscode.window.showInformationMessage('Please select a file first...');\n    }\n    const inputBoxOptions = <vscode.InputBoxOptions>{\n      prompt: 'Add Bookmark name, Flow name, index',\n      placeHolder: 'Bookmark name, Flow name, index',\n    };\n    vscode.window.showInputBox(inputBoxOptions).then(enteredText => {\n      if (!enteredText) {\n        vscode.window.showInformationMessage('Please enter Bookmark Name,Flow Name and/or index');\n        return;\n      }\n      bookmarkController.addBookmark(activeEditor, enteredText);\n      vscode.commands.executeCommand('flowBookmarksView.refreshEntry');\n    });\n  });\n\n  // Edit Bookmark from Sidebar\n  const editBookmark = vscode.commands.registerCommand('flowBookmarksView.editEntry', node => {\n    const [index, bookmarkName] = node.label.split('. '),\n      filePath = node.command.arguments[0],\n      lineNumber = node.command.arguments[1],\n      flowName = node.command.arguments[2],\n      currentLabel = bookmarkName + ', ' + flowName + ', ' + index,\n      inputBoxOptions = <vscode.InputBoxOptions>{\n        prompt: 'Edit Bookmark name, Flow name, index',\n        placeHolder: 'Bookmark name, Flow name, index',\n        value: currentLabel,\n      };\n    vscode.window.showInputBox(inputBoxOptions).then(enteredText => {\n      if (!enteredText) {\n        vscode.window.showInformationMessage('Please enter Bookmark Name,Flow Name and/or index');\n        return;\n      }\n      bookmarkController.editBookmark(filePath, lineNumber, enteredText);\n      vscode.commands.executeCommand('flowBookmarksView.refreshEntry');\n    });\n  });\n\n  // Clear the bookmark from Command Prompt\n  let clearBookmark = vscode.commands.registerCommand('flowbookmark.clear', () => {\n    const activeEditor = vscode.window.activeTextEditor;\n    if (!activeEditor) {\n      return vscode.window.showWarningMessage('Select a file first');\n    }\n    bookmarkController.clearBookmark(activeEditor);\n    vscode.commands.executeCommand('flowBookmarksView.refreshEntry');\n  });\n\n  // Delete Bookmark from Sidebar\n  const deleteBookmark = vscode.commands.registerCommand('flowBookmarksView.deleteBookmark', node => {\n    const [index, bookmarkName] = node.label.split('. '),\n      filePath = node.command.arguments[0],\n      lineNumber = node.command.arguments[1],\n      flowName = node.command.arguments[2];\n    bookmarkController.deleteBookmark(filePath, lineNumber);\n    vscode.commands.executeCommand('flowBookmarksView.refreshEntry');\n  });\n\n  // Clear All bookmarks from Command Prompt\n  let clearAllBookmarks = vscode.commands.registerCommand('flowbookmark.clearAll', () => {\n    bookmarkController.clearAllBookmarks();\n    vscode.commands.executeCommand('flowBookmarksView.refreshEntry');\n  });\n\n  // Jump To bookmark from Sidebar\n  vscode.commands.registerCommand('flowBookmark.jumpTo', (filePath: string, lineNumber: string) => {\n    editorController.openTextDocument(filePath, lineNumber);\n  });\n\n  // Testing purpose helloWorld\n  // let disposable = vscode.commands.registerCommand('flowbookmark.helloWorld', () => {\n  //   vscode.window.showInformationMessage('Hello from FlowBookmark!');\n  // });\n\n  // context.subscriptions.push(disposable);\n  context.subscriptions.push(addNew);\n  context.subscriptions.push(editBookmark);\n  context.subscriptions.push(clearBookmark);\n  context.subscriptions.push(deleteBookmark);\n  context.subscriptions.push(clearAllBookmarks);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() {}\n"],"sourceRoot":""}